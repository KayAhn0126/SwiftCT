# 1238 íŒŒí‹°
- ë‹¤ìµìŠ¤íŠ¸ë¼

## ğŸ ì§€ë¬¸ í•´ì„
- Nê°œì˜ ë§ˆì„ì— í•™ìƒì´ í•œëª…ì”© ì‚´ê³  ìˆë‹¤.
- ì´ í•™ìƒë“¤ì´ Xë²ˆ ë§ˆì„ì— ëª¨ì—¬ì„œ íŒŒí‹°ë¥¼ í•˜ê¸°ë¡œ í–ˆë‹¤.
- ì´ ë§ˆì„ë“¤ ì‚¬ì´ì—ëŠ” ì´ Mê°œì˜ ë‹¨ë°©í–¥ ë„ë¡œë“¤ì´ ìˆê³  ì´ë¥¼ ì§€ë‚˜ëŠ”ë° Të§Œí¼ ì‹œê°„ì„ ì†Œë¹„í•œë‹¤.
- ê°ê°ì˜ í•™ìƒë“¤ì€ íŒŒí‹°ì— ì°¸ì„ í•˜ê¸° ìœ„í•´ ê±¸ì–´ê°€ì•¼ í•˜ê³  ëë‚˜ë©´ ë‹¤ì‹œ ê·¸ë“¤ì˜ ë§ˆì„ë¡œ ëŒì•„ì™€ì•¼ í•œë‹¤.
- í•™ìƒë“¤ì€ ê²Œì„ëŸ¬ì„œ ìµœë‹¨ ì‹œê°„ì— ì˜¤ê³  ê°€ê¸°ë¥¼ ì›í•œë‹¤.
- ë„ë¡œë“¤ì€ ë‹¨ë°©í–¥ì´ê¸° ë•Œë¬¸ì— ì˜¤ê³  ê°€ëŠ” ê¸¸ì´ ë‹¤ë¥¼ ìˆ˜ ìˆê³ , ê·¸ì— ë”°ë¥¸ ë¹„ìš©ë„ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.
- ëª¨ë“  í•™ìƒë“¤ ì¤‘ ì˜¤ê³  ê°€ëŠ”ë° ê°€ì¥ ë§ì€ ì‹œê°„ì„ ì†Œë¹„í•œ í•™ìƒì˜ ì†Œìš”ì‹œê°„ì„ ì¶œë ¥í•˜ë©´ ëœë‹¤.
- ìµœëŒ€ ë§ˆì„ or í•™ìƒ ìˆ˜ëŠ” 1,000
- ìµœëŒ€ ê°„ì„ ì˜ ê°¯ìˆ˜ëŠ” 10,000

## ğŸ ë¬¸ì œ ì ‘ê·¼
- ë¬¸ì œì˜ ì˜ˆì œë¥¼ í†µí•´ ë©”ì¸ ë¡œì§ì„ ì•Œì•„ë³´ì.
- 4ëª…ì˜ í•™ìƒ 8ê°œì˜ ê°„ì„  ì •ë³´ ë° ë¹„ìš© 2ë²ˆ ë§ˆì„ì—ì„œ íŒŒí‹°.
- ë¨¼ì € ë‘ê°€ì§€ ì¼€ì´ìŠ¤ë¥¼ ìƒê°í•´ì•¼í•œë‹¤.
- í•™ìƒë“¤ì´ Xë§ˆì„ë¡œ ê°ˆë•Œ ìµœë‹¨ ì‹œê°„ìœ¼ë¡œ ê°€ëŠ” ê²½ìš°
    - 1 -> 2
    - 2 -> 2
    - 3 -> 2
    - 4 -> 2
- íŒŒí‹°ê°€ ëë‚˜ê³  í•™ìƒë“¤ì´ ë‹¤ì‹œ ê·¸ë“¤ì˜ ë§ˆì„ë¡œ ê°ˆë•Œ ìµœë‹¨ ì‹œê°„ìœ¼ë¡œ ê°€ëŠ” ê²½ìš°
    - 2 -> 1
    - 2 -> 2
    - 2 -> 3
    - 2 -> 4
- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ í•˜ë‚˜ì˜ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ë…¸ë“œê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- ì¦‰,
    - 1ë²ˆ ë§ˆì„ì—ì„œ ëª¨ë“  ë§ˆì„ê¹Œì§€ì˜ ìµœë‹¨ ì†Œìš” ì‹œê°„.
    - 2ë²ˆ ë§ˆì„ì—ì„œ ëª¨ë“  ë§ˆì„ê¹Œì§€ì˜ ìµœë‹¨ ì†Œìš” ì‹œê°„.
    - 3ë²ˆ ë§ˆì„ì—ì„œ ëª¨ë“  ë§ˆì„ê¹Œì§€ì˜ ìµœë‹¨ ì†Œìš” ì‹œê°„.
    - ...
    - Në²ˆ ë§ˆì„ì—ì„œ ëª¨ë“  ë§ˆì„ê¹Œì§€ì˜ ìµœë‹¨ ì†Œìš” ì‹œê°„.
- ìµœëŒ€ ë§ˆì„ ìˆ˜ê°€ 1,000ëª…ì´ê³  ë§ˆì„ì—ì„œ ë‹¤ë¥¸ ë§ˆì„ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” 999. ìµœì•…ì˜ ê²½ìš°ì—ë„ 1001 by 1001ì§œë¦¬ 2ì°¨ì› ë°°ì—´ì„ ë§Œë“¤ë©´ ëœë‹¤!
    - êµ³ì´ 1001 * 1001 í¬ê¸°ì˜ ë°°ì—´ ë§ê³  N + 1 * N + 1 í¬ê¸°ë¡œ ë§Œë“¤ë©´ ëœë‹¤!
    - ì¦‰, ì´ 2ì°¨ì› ë°°ì—´ì€ í•™ìƒë“¤ì´ Xë§ˆì„ê¹Œì§€ ê°€ëŠ” ê²½ìš°, íŒŒí‹°ê°€ ëë‚˜ê³  ê°ìì˜ ë§ˆì„ë¡œ ìµœë‹¨ ì‹œê°„ìœ¼ë¡œ ëŒì•„ì˜¤ëŠ” ê²½ìš°ê¹Œì§€ì˜ ì •ë³´ë¥¼ ê°€ì§„ë‹¤.
    - costArr[ì–´ëŠ ë§ˆì„ì—ì„œ][ì–´ëŠ ë§ˆì„ê¹Œì§€]ì˜ í˜•íƒœë¥¼ ê°€ì§„ë‹¤.

## ğŸ ë¬¸ì œ í’€ì´ ë° ì „ì²´ ì½”ë“œ
### ğŸ“– ì „ì²´ ì½”ë“œë¥¼ ë³´ê¸°ì „..
- ëŒ€ëµì ì¸ ìˆœì„œ
    - ì—°ê²° ì •ë³´(from to cost)ë¥¼ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ë°›ëŠ”ë‹¤.
    - 1ë²ˆ ë§ˆì„ë¶€í„° ì‹œì‘í•´ Në²ˆ ë§ˆì„ê¹Œì§€ ìì‹ ì˜ ë§ˆì„ì„ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ë¥¸ ëª¨ë“  ë§ˆì„ê¹Œì§€ ìµœë‹¨ì‹œê°„ì„ êµ¬í•œë‹¤.
        - pq(min heap)ì„ ë§Œë“ ë‹¤.
        - pqì— í˜„ì¬ ë§ˆì„(ë…¸ë“œ)ë²ˆí˜¸ì™€ ìê¸° ìì‹ ì˜ ë§ˆì„ê¹Œì§€ëŠ” 0ë§Œí¼ ê±¸ë¦¬ë¯€ë¡œ 0ì„ EdgeNode êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ í˜•íƒœë¡œ ë„£ëŠ”ë‹¤.
        - costArr[í˜„ì¬ë§ˆì„][í˜„ì¬ë§ˆì„]ì„ 0ìœ¼ë¡œ ì„¤ì •.
    - pqê°€ ë¹Œë•Œê¹Œì§€ ë¹„ìš©ì´ ì ì€ ë…¸ë“œë¥¼ ê³„ì† ë¨¼ì € ë½‘ì•„ ì´ì „ì˜ ê°’ê³¼ ë¹„êµí•˜ë©´ì„œ ì§„í–‰í•œë‹¤.
- ì´ ë¬¸ì œì˜ í¬ì¸íŠ¸ -> "**Nëª…ì˜ í•™ìƒë“¤ ì¤‘ ì˜¤ê³  ê°€ëŠ”ë° ê°€ì¥ ì˜¤ë˜ ê±¸ë¦¬ëŠ” í•™ìƒì˜ ì†Œìš”ì‹œê°„ì„ ì¶œë ¥í•œë‹¤.**"ë¥¼ ì½”ë“œë¡œ ë³´ì!
```swift
var result = Int.min
for i in 1...N {
    // i(ë§ˆì„)ì—ì„œ X(ë§ˆì„)ê¹Œì§€ì˜ ìµœì†Œë¹„ìš© + X(ë§ˆì„)ì—ì„œ i(ë§ˆì„)ê¹Œì§€ì˜ ìµœì†Œë¹„ìš©ì„ ë”í•œ í›„ ê·¸ ì¤‘ ê°€ì¥ í° ê°’ì„ êµ¬í•œë‹¤.
    let temp = costArr[i][X] + costArr[X][i]
    if temp > result {
        result = temp
    }
}
print(result) 
```

### ğŸ“– ì „ì²´ ì½”ë“œ
```swift
import Foundation

public struct Heap<T> {
    var nodes: [T] = []
    let comparer: (T,T) -> Bool
    
    var isEmpty: Bool {
        return nodes.isEmpty
    }
    
    init(comparer: @escaping (T,T) -> Bool) {
        self.comparer = comparer
    }
    
    func peek() -> T? {
        return nodes.first
    }
    
    mutating func insert(_ element: T) {
        var index = nodes.count
        
        nodes.append(element)
        
        while index > 0, comparer(nodes[index], nodes[(index-1)/2]) {
            nodes.swapAt(index, (index-1)/2)
            index = (index-1)/2
        }
    }
    
    mutating func delete() -> T? {
        guard !nodes.isEmpty else {
            return nil
        }
        
        if nodes.count == 1 {
            return nodes.removeFirst()
        }
        
        let result = nodes.first
        nodes.swapAt(0, nodes.count-1)
        _ = nodes.popLast()
        
        var index = 0
        
        while index < nodes.count {
            let left = index * 2 + 1
            let right = left + 1
            
            if right < nodes.count {
                if comparer(nodes[right], nodes[left]),
                   comparer(nodes[right], nodes[index]) {
                    nodes.swapAt(right, index)
                    index = right
                } else if comparer(nodes[left], nodes[index]){
                    nodes.swapAt(left, index)
                    index = left
                } else {
                    break
                }
            } else if left < nodes.count {
                if comparer(nodes[left], nodes[index]) {
                    nodes.swapAt(left, index)
                    index = left
                } else {
                    break
                }
            } else {
                break
            }
        }
        return result
    }
}

extension Heap where T: Comparable {
    init() {
        self.init(comparer: <) // min heap
        // self.init(comparer: >)  max heap
    }
}

struct EdgeNode: Comparable {
    var node: Int
    var cost: Int
    
    static func < (_ lhs: EdgeNode, _ rhs: EdgeNode) -> Bool {
        return lhs.cost < rhs.cost
    }
}

let NMX = readLine()!.split(separator: " ").map { Int(String($0))! }
let N = NMX[0]
let M = NMX[1]
let X = NMX[2]
var costArr = [[Int]](repeating: [Int](repeating: Int.max, count: N + 1), count: N + 1)
var connectionInfo = [[(Int,Int)]](repeating: [(Int,Int)](), count: N + 1)
for _ in 0..<M {
    let fromToCost = readLine()!.split(separator: " ").map { Int(String($0))! }
    let from = fromToCost[0]
    let to = fromToCost[1]
    let cost = fromToCost[2]
    connectionInfo[from].append((to, cost))
}

for i in 1...N {
    var pq = Heap<EdgeNode>(comparer: <)
    pq.insert(EdgeNode(node: i, cost: 0))
    costArr[i][i] = 0
    
    while !pq.isEmpty {
        let now = pq.delete()!
        if costArr[i][now.node] < now.cost { continue }
        
        for info in connectionInfo[now.node] {
            let nextNode = info.0
            let costToNextNode = info.1
            let tempCost = now.cost + costToNextNode
            if tempCost < costArr[i][nextNode] {
                costArr[i][nextNode] = tempCost
                pq.insert(EdgeNode(node: nextNode, cost: tempCost))
            }
        }
    }
}
var result = Int.min
for i in 1...N {
    let temp = costArr[i][X] + costArr[X][i]
    if temp > result {
        result = temp
    }
}
print(result)
```
## ğŸ ì°¸ê³ 
- [Priority Queue êµ¬í˜„ ì¶œì²˜](https://kayahn93.tistory.com/5)
