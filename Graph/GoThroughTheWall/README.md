# 2206 ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸°

## ğŸ ì–´ë ¤ìš´ ë¬¸ì œì´ë‹ˆ ì§€ë¬¸ì„ ë‹¤ì‹œ ì½ì–´ë³´ì
- NÃ—Mì˜ í–‰ë ¬ë¡œ í‘œí˜„ë˜ëŠ” ë§µì´ ìˆë‹¤. 
- ë§µì—ì„œ 0ì€ ì´ë™í•  ìˆ˜ ìˆëŠ” ê³³ì„ ë‚˜íƒ€ë‚´ê³ , 1ì€ ì´ë™í•  ìˆ˜ ì—†ëŠ” ë²½ì´ ìˆëŠ” ê³³ì„ ë‚˜íƒ€ë‚¸ë‹¤.
- ë‹¹ì‹ ì€ (1, 1)ì—ì„œ (N, M)ì˜ ìœ„ì¹˜ê¹Œì§€ ì´ë™í•˜ë ¤ í•˜ëŠ”ë°, ì´ë•Œ ìµœë‹¨ ê²½ë¡œë¡œ ì´ë™í•˜ë ¤ í•œë‹¤.
- ìµœë‹¨ê²½ë¡œëŠ” ë§µì—ì„œ ê°€ì¥ ì ì€ ê°œìˆ˜ì˜ ì¹¸ì„ ì§€ë‚˜ëŠ” ê²½ë¡œë¥¼ ë§í•˜ëŠ”ë°, ì´ë•Œ ì‹œì‘í•˜ëŠ” ì¹¸ê³¼ ëë‚˜ëŠ” ì¹¸ë„ í¬í•¨í•´ì„œ ì„¼ë‹¤.
- ë§Œì•½ì— ì´ë™í•˜ëŠ” ë„ì¤‘ì— í•œ ê°œì˜ ë²½ì„ ë¶€ìˆ˜ê³  ì´ë™í•˜ëŠ” ê²ƒì´ ì¢€ ë” ê²½ë¡œê°€ ì§§ì•„ì§„ë‹¤ë©´, ë²½ì„ í•œ ê°œ ê¹Œì§€ ë¶€ìˆ˜ê³  ì´ë™í•˜ì—¬ë„ ëœë‹¤.
- í•œ ì¹¸ì—ì„œ ì´ë™í•  ìˆ˜ ìˆëŠ” ì¹¸ì€ ìƒí•˜ì¢Œìš°ë¡œ ì¸ì ‘í•œ ì¹¸ì´ë‹¤.
- ë§µì´ ì£¼ì–´ì¡Œì„ ë•Œ, ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•´ ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

## ğŸ ë¬¸ì œ ì ‘ê·¼
### ğŸ“– ì²˜ìŒì— ì‹œë„í–ˆë˜ ë°©ë²•
    - ë§µ ì „ì²´ë¥¼ ëŒë©´ì„œ 1ì˜ ìœ„ì¹˜(y,x) í˜•íƒœë¥¼ ëª¨ë‘ ì €ì¥í•œë‹¤.
    - í•´ë‹¹ 1ì„ 0ìœ¼ë¡œ ë°”ê¾¼ë‹¤.
    - BFSë¥¼ ëŒë¦¬ê³ 
    - ë°©ê¸ˆ 0ìœ¼ë¡œ ë°”ê¿¨ë˜ ìœ„ì¹˜ë¥¼ ë‹¤ì‹œ 1ë¡œ ì›ìƒë³µêµ¬ ì‹œì¼œì¤€ë‹¤.
    - ìœ„ì˜ ìŠ¤í…ì„ ë°˜ë³µí•œë‹¤.
- í•´ë‹¹ ë¡œì§ì˜ ê°€ì¥ í° ë¬¸ì œì . -> ì‹œê°„ì´ˆê³¼
- ì…ë ¥ì˜ ë²”ìœ„ë¥¼ ë³´ì.
- Nì˜ ìµœëŒ€ 1000, Mì˜ ìµœëŒ€ 1000.
- ë§µ ì‚¬ì´ì¦ˆ = 1000 * 1000
- BFS íƒìƒ‰ = 1000 * 1000
- ìœ„ì˜ ë¡œì§ëŒ€ë¡œ ì‹¤í–‰í•˜ë©´ ì‹œê°„ ë³µì¡ë„ëŠ” 10^12
### ğŸ“– 3ì°¨ì› ë°°ì—´ì„ ì´ìš©í•œ ìƒˆë¡œìš´ ë°©ë²•
- 3ì°¨ì› ë°°ì—´ì˜ ë§ˆì§€ë§‰ ë°°ì—´ì€ ë¶€ì‰ˆëŠ”ì§€, ì•ˆ ë¶€ì‰ˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” ìš©ë„.
- ì²˜ìŒì—ëŠ” ë¶€ì‹œì§€ ì•Šì€ ìƒíƒœì´ë‹ˆ 0ìœ¼ë¡œ ë‘ê³  ê·¸ ìƒíƒœì—ì„œ ì²˜ìŒ ë²½ì„ ë§Œë‚˜ë©´ 1ë¡œ ë³€í™˜í•œ ìƒíƒœë¡œ ê³„ì† BFSë¥¼ ì§„í–‰í•œë‹¤.

## ğŸ ì‹œê°„ ì´ˆê³¼ ì½”ë“œ
```swift
import Foundation

let NM = readLine()!.split(separator: " ").map { Int(String($0))! }
let N = NM[0]
let M = NM[1]

var adjMatrix = [[Int]](repeating: [Int](), count: N)

for i in 0..<N {
    adjMatrix[i].append(contentsOf: readLine()!.map { Int(String($0))! })
}

var oneLocation: [(Int, Int)] = []
for i in 0..<N {
    for j in 0..<M {
        if adjMatrix[i][j] == 1 {
            oneLocation.append((i,j))
        }
    }
}

let dy = [-1,0,1,0]
let dx = [0,1,0,-1]

var result = 987654321
for i in oneLocation {
    var visited = [[Int]](repeating: [Int](repeating: 0, count: M), count: N)
    var bfsQueue: [(Int,Int)] = [], idx = 0
    adjMatrix[i.0][i.1] = 0
    
    visited[0][0] = 1
    bfsQueue.append((0,0))
    
    while idx < bfsQueue.count {
        let currentLocation = bfsQueue[idx]; idx += 1
        let currentY = currentLocation.0
        let currentX = currentLocation.1
        for i in 0..<4 {
            let ny = currentY + dy[i]
            let nx = currentX + dx[i]
            if ny < 0 || nx < 0 || ny >= N || nx >= M { continue }
            if visited[ny][nx] > 0 || adjMatrix[ny][nx] == 1 { continue }
            visited[ny][nx] = visited[currentY][currentX] + 1
            bfsQueue.append((ny,nx))
        }
    }
    adjMatrix[i.0][i.1] = 1
    let roundResult = visited[N-1][M-1]
    if roundResult == 0 { // ê°€ëŠ” ë°©ë²•ì´ ì—†ë‹¤ë©´
        continue
    } else { // ê°€ëŠ” ë°©ë²•ì´ ìˆë‹¤ë©´
        result = result > roundResult ? roundResult : result
    }
    
}
if result == 987654321 {
    print(-1)
} else {
    print(result)
}
```

## ğŸ í†µê³¼ ì½”ë“œ
```swift
import Foundation

let NM = readLine()!.split(separator: " ").map { Int(String($0))! }
let N = NM[0]
let M = NM[1]

var adjMatrix = [[Int]](repeating: [Int](), count: N)

for i in 0..<N {
    adjMatrix[i].append(contentsOf: readLine()!.map { Int(String($0))! })
}

let dy = [-1,0,1,0]
let dx = [0,1,0,-1]

// 3ì°¨ì› ë°°ì—´
var visited = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating: 0, count: 2), count: M), count: N)

func bfs() -> Int {
    var bfsQueue: [(Int,Int,Int)] = [], idx = 0
    visited[0][0][0] = 1
    bfsQueue.append((0,0,0))
    while idx < bfsQueue.count {
        let currentLocation = bfsQueue[idx]; idx += 1
        let currentY = currentLocation.0
        let currentX = currentLocation.1
        let currentShatterStatus = currentLocation.2
        if currentY == N - 1 && currentX == M - 1 { // ëª©í‘œ ìœ„ì¹˜ì— ë„ë‹¬ í–ˆë‹¤ë©´..?
            return visited[N-1][M-1][currentShatterStatus]
        }
        for i in 0..<4 {
            let ny = currentY + dy[i]
            let nx = currentX + dx[i]
            if ny < 0 || nx < 0 || ny >= N || nx >= M { continue }
            if visited[ny][nx][currentShatterStatus] > 0 { continue } // ë¬¸ì œì˜ íŠ¹ì„±ìƒ ì—¬ê¸°ì„œ ë²½ ì²´í¬ í•˜ì§€ ì•ŠìŒ
            if adjMatrix[ny][nx] == 0 { // ë§µì—ì„œ ë‹¤ìŒ ê°€ë ¤ëŠ” ê³³ì´ ë²½ì´ ì•„ë‹ˆë¼ë©´..? -> ì¼ë°˜ì ì¸ BFS ìƒí™©ì²˜ëŸ¼ í˜ëŸ¬ê°
                visited[ny][nx][currentShatterStatus] = visited[currentY][currentX][currentShatterStatus] + 1
                bfsQueue.append((ny,nx,currentShatterStatus))
            } else { // ë§µì—ì„œ ë‹¤ìŒ ê°€ë ¤ëŠ” ê³³ì´ ë²½ì´ë¼ë©´..?? -> ì´ì „ì— ë²½ì„ ë¶€ì‰ˆëŠ”ì§€ ì²´í¬ í›„ ë¶„ê¸°ì²˜ë¦¬
                if currentShatterStatus == 0 { // ì•„ì§ ë²½ì„ ë¶€ì‹œì§€ ì•ŠìŒ
                    visited[ny][nx][1] = visited[currentY][currentX][currentShatterStatus] + 1
                    bfsQueue.append((ny,nx,1))
                } else { // ì—¬ê¸°ê¹Œì§€ ì˜¤ë©´ì„œ ë²½ì„ ë¶€ì‹ ì ì´ ìˆìŒ
                    continue
                }
            }
        }
    }
    return -1
}
print(bfs())
```
