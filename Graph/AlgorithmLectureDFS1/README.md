# 24479 알고리즘 수업 - 깊이 우선 탐색 1

## 🍎 키워드
- 인접리스트
- 양방향 간선 DFS
- 정점의 갯수 최대 10만개 정렬
    - sort()
    - sorted()
- 세부 조건

## 🍎 왜 인접 행렬 대신 인접 리스트를?
- 처음에는 인접 행렬을 사용 했다가 인접 리스트로 바꾼데는 아래와 같은 이유가 있다.
    - 정점에 비해 간선이 상대적 적음
        - 굳이 2차원 배열을 만들 필요 없음으로 공간 복잡도에서 우위
    - 모든 정점을 방문하지 않음
        - 스타트에서 방문 하지 못하면 아예 필요가 없음

## 🍎 정렬을 할 때 무엇을 기준으로 했나?
- sort()와 sorted()중 sorted()를 사용했다.
- 먼저, 둘다 O(nlogn)의 시간복잡도를 갖는것은 동일했고, 원본을 정렬할지, 아니면 메모리를 더블로 사용하고 복사본을 만들것인지 비교해봤다.
- 이 문제의 메모리 제한이 512MB로 충분했고, 다른 문제들을 풀 때도 원본은 왠만하면 건들지 않는것이 추후 데이터 일관성에 대한 문제를 막을 수 있다고 생각했다.
- 결론은 sorted() 사용했고, sorted()마저 방문하지 않는 노드에는 적용하지 않았다.

## 🍎 테스트 케이스를 통해 문제에서 놓친점 알아보기
### 📖 문제의 요구사항
- 1.정점 R에서 시작 + DFS
- 2.모든 간선의 가중치는 1
- 3.인접 정점은 오름차순으로 방문
- 4.출력에서 i 번째 줄에는 정점 i의 방문 순서를 출력
- 5.시작 정점에서 방문할 수 없는 정점의 경우 0을 출력한다

### 📖 문제에 나와있는 테스트 케이스를 보자
```swift
// 입력
5 5 1
1 4
1 2
2 3
2 4
3 4

// 출력
1
4
3
2
0
```
- 이 경우 N = 5, M = 5, R = 1
    - arrMatrix[1][4,2]
    - arrMatrix[2][3,4]
    - arrMatrix[3][4]
- 위와 같이 표현 할 수 있다. 이제 문제에서 요구하는 사항을 적용해보자.
- 3번 요구사항, 인접 정점은 오름차순으로 방문
- 즉, arrMatrix[u][v] 형태에서 인접 정점인 v를 오름차순 정렬해야한다. (하단 코드 참고)
- 자, 정렬을 한 코드는 밑에서 다시 확인하고 요구 사항 4번을 보면, i번째 줄에는 정점 i를 몇번째로 방문했는지 출력하라고 나와있다.
    - 이 부분은 dfs를 실행할때마다 아래와 같이 visited 배열에서 해당 노드의 인덱스에 count를 대입했다.
    - 그리고 인접 노드를 방문하기전 count를 올려서 다음 방문하는 노드의 순서를 정해주었다.
```swift
func dfs(_ node: Int) {
    visited[node] = count
    arrMatrix[node] = arrMatrix[node].sorted()
    for i in 0..<arrMatrix[node].count {
        if visited[arrMatrix[node][i]] != 0 { continue }
        count += 1
        dfs(arrMatrix[node][i])
    }
}
```
- 마지막엔 0번째 인덱스를 제외하고 모두 출력해주었다.
```swift
visited.enumerated().forEach {
    if $0.offset != 0 {
        print($0.element)
    }
}
```

### 📖 제출 후 3%에서 '틀렸습니다'
- 무엇이 틀렸는지 몰라서 반례들을 찾아봤다.
- 반례를 통한 두번째 테스트 케이스
```swift
// 입력
6 4 1
2 3
1 4
1 5
4 6

// 출력
1
0
0
2
4
3
```
- 이 반례의 입력을 그대로 대입했더니
```swift
1
5
6
2
4
3
```
- 위와 같이 출력되었다.
- 1번과 5번이 결합된 요구사항을 지키지 않아서 발생한 문제이다.
- 일반 dfs문제를 풀듯이 아래와 같은 코드를 사용했었고 아래와 같이 해결했다.
```swift
// 문제
for node in 1..<N+1 {
    dfs(node)
}

// 해결
dfs(R)
```
### 📖 또 다시 3%에서 '틀렸습니다'
- 또 다른 반례를 찾았다.
```swift
// 입력
5 5 2
1 4
1 2
2 3
2 4
3 4

// 출력
2
1
4
3
0
```
- 이 반례의 입력을 그대로 대입했더니
```swift
0
1
2
3
0
```
- R은 2이니까 dfs(2)부터 시작해보자.
- 2(1) -> 3(2) -> 4(3)
    - 괄호안에 숫자는 방문 순서
- 어떻게 해야 2 1 4 3 0 이 나오는지 생각하다 내 코드가 단방향 간선이라는것을 확인하고, 양방향으로 구현했더니 잘 나온다.
- 단방향일때와 양방향일때 차이점을 인접리스트를 통해서 확인 해보자.
- 단방향
    - [1][2,4]
    - [2][3,4]
    - [3][4]
- 양방향
    - [1][2,4]
    - [2][1,3,4]
    - [3][2,4]
    - [4][1,2,3]
    - 2 -> 1 -> 4 -> 3

## 🍎 느낀점
- 지문이 많기도 했고 다른 문제들보다 명확하지 못한 부분은 아쉬웠지만 정말 좋은 문제였다. (많이 배웠다)
- 세부 조건 체크가 다른 문제에 비해 많았다. 정답 비율 23%. 납득이 간다.
