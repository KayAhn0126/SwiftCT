# 1325 íš¨ìœ¨ì ì¸ í•´í‚¹

## ðŸŽ í‚¤ì›Œë“œ
- ë¹ ë¥¸ IO
- ë°°ì—´ê³¼ ì¸ë±ìŠ¤ë¥¼ ì´ìš©í•œ Queue
- ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì„¤ê³„
- BFS
- ìµœëŒ€ê°’ì´ 2ê°œ ì´ìƒì¼ë•Œ ì²˜ë¦¬ ë°©ë²• + ì˜¤ë¦„ì°¨ìˆœ

## ðŸŽ ë¬¸ì œ ì„¤ê³„
- ì§€ë¬¸ì—ì„œ "ì´ íšŒì‚¬ì˜ ì»´í“¨í„°ëŠ” ì‹ ë¢°í•˜ëŠ” ê´€ê³„ì™€, ì‹ ë¢°í•˜ì§€ ì•ŠëŠ” ê´€ê³„ë¡œ ì´ë£¨ì–´ì ¸ ìžˆëŠ”ë°, Aê°€ Bë¥¼ ì‹ ë¢°í•˜ëŠ” ê²½ìš°ì—ëŠ” Bë¥¼ í•´í‚¹í•˜ë©´, Aë„ í•´í‚¹í•  ìˆ˜ ìžˆë‹¤ëŠ” ì†Œë¦¬ë‹¤."ë¥¼ ë³´ê³  ì¸ì ‘ë¦¬ìŠ¤íŠ¸ê°€ ìƒê°ë‚¬ë‹¤.
- ì˜ˆì œ ìž…ë ¥ì„ ë³´ìž
```swift
5 4
3 1
3 2
4 3
5 3
```
- N = 5, M = 4
- ì´ ì»´í“¨í„° ìˆ«ìž 5 ì–´ë–¤ ì»´í“¨í„°ê°€ ì–´ë–¤ ì»´í“¨í„°ë¥¼ ì‹ ë¢°í•˜ëŠ”ì§€ ì•Œë ¤ì£¼ëŠ” ë¯¿ìŒ ê³ ë¦¬ 4ê°œ(ê°„ì„ )
- 3 (ì´ ì»´í“¨í„°ê°€) 1 (ì´ ì»´í“¨í„°ë¥¼ ì‹ ë¢°)
- 3 (ì´ ì»´í“¨í„°ê°€) 2 (ì´ ì»´í“¨í„°ë¥¼ ì‹ ë¢°)
- 4 (ì´ ì»´í“¨í„°ê°€) 3 (ì´ ì»´í“¨í„°ë¥¼ ì‹ ë¢°)
- 5 (ì´ ì»´í“¨í„°ê°€) 3 (ì´ ì»´í“¨í„°ë¥¼ ì‹ ë¢°)
- Xì»´í“¨í„°ë¥¼ ì‹ ë¢°í•˜ëŠ” ì»´í“¨í„°ë“¤ Yë¥¼ ì•„ëž˜ì™€ ê°™ì´ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•  ìˆ˜ ìžˆë‹¤.
- [1][3]
- [2][3]
- [3][4,5]

## ðŸŽ ë¬¸ì œ í•´ê²°
- Nì˜ ë²”ìœ„ê°€ 10,000ì´ê³  ì‹œê°„ë³µìž¡ë„ëŠ” O(10000 * 9999)ì¸ O(N^2)ìœ¼ë¡œ ìž¡ì•˜ë‹¤
- ì•„ëž˜ì™€ ê°™ì€ ê²½ìš°ê°€ ìƒê¸¸ ìˆ˜ ìžˆê¸° ë•Œë¬¸ì—..
    - [1][2] -> 1ë²ˆì„ ì‹ ë¢°í•˜ëŠ” 2ë²ˆ ì»´í“¨í„°
    - [2][3] -> 2ë²ˆì„ ì‹ ë¢°í•˜ëŠ” 3ë²ˆ ì»´í“¨í„°
    - [3][4] -> 3ë²ˆì„ ì‹ ë¢°í•˜ëŠ” 4ë²ˆ ì»´í“¨í„°
    - [4][5] -> ...
    - [5][6] -> ...
    - [6][7] -> ...
    - [7][8]
    - [8][9]
    - [9][10]
    - [10][11]
    - [N][N+1]  -> Në²ˆì„ ì‹ ë¢°í•˜ëŠ” N+1ë²ˆ ì»´í“¨í„°
- 10000 * 10000? ë¸Œë£¨íŠ¸í¬ìŠ¤ ë ˆì¸ ê³ !
- bfsë¥¼ ì´ìš©í•´ì„œ í•œ depthì”© ë“¤ì–´ê°ˆë•Œë§ˆë‹¤ í•´í‚¹ ìˆ«ìžì— +1ì„ í•´ì¤€ë‹¤.
```swift
for i in 1...N {
    let result = bfs(i)
    biggestNum = biggestNum > result ? biggestNum : result
    biggestList[i] = result
}
```
- biggestNumì€ ìµœëŒ€ê°’ì„ ê°±ì‹ í•˜ëŠ” ë³€ìˆ˜ì´ê³  biggestListëŠ” ê°’ë“¤ì´ ì €ìž¥ë˜ëŠ” ë°°ì—´ì´ë‹¤.
- ìœ„ì™€ ê°™ì€ ì½”ë“œëŠ” ìµœëŒ€ê°’ì´ 2ê°œ ì´ìƒì¼ìˆ˜ë„ ìžˆì„ë•Œ ì‚¬ìš©í•œë‹¤.
- biggestList ë°°ì—´ì—ì„œ biggestNumê³¼ ê°™ì€ ê°’ì„ ê°€ì§€ëŠ” ëª¨ë“  ìœ„ì¹˜ ì¶œë ¥
```swift
for i in 1...N {
    if biggestNum == biggestList[i] {
        print(i, terminator: " ")
    }
}
```

## ðŸŽ ë†“ì¹œ ë¶€ë¶„
- ì²˜ìŒì—” ë°©ë¬¸ ë°°ì—´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  í’€ì—ˆë‹¤.
- ë‹¤ì‹œ ìƒê°í•´ë³´ë‹ˆ, ì˜ˆì œ ìž…ë ¥ì—ëŠ” ë‚˜ì™€ìžˆì§€ ì•Šì§€ë§Œ ë‘ ëŒ€ì˜ ì»´í“¨í„°ê°€ ì„œë¡œ ì‹ ë¢°í•˜ê³  ìžˆëŠ” ê²½ìš°, ë‚´ê°€ ì‚¬ìš©í•œ ë¡œì§ì´ ì •ìƒì ì´ì§€ ì•Šê²Œ ìž‘ë™í•  ìˆ˜ ìžˆì–´ì„œ ë°©ë¬¸ ë°°ì—´ì„ ì‚¬ìš©í–ˆë‹¤.
- ì˜ˆì‹œ
- [1][3]
- [3][1]
- ë°©ë¬¸ ì²´í¬ë¥¼ ì•ˆí•´ì£¼ë©´ dfs í•¨ìˆ˜ê°€ ê³„ì† ì‹¤í–‰ë˜ì„œ ëë‚˜ì§€ ì•Šì•˜ì„ê²ƒ.

## ðŸŽ ìµœëŒ€ê°’ì´ 2ê°œ ì´ìƒì¼ë•Œ ì²˜ë¦¬ ë°©ë²• + ì˜¤ë¦„ì°¨ìˆœ
```swift
for i in 1...N {
    clearVisited()
    let number = dfs(i)
    biggestList[i] = number
    biggestNum = biggestList[i] > biggestNum ? biggestList[i] : biggestNum
}

for i in 1...N {
    if biggestNum == biggestList[i] {
        print(i, terminator: " ")
    }
}
```

## ðŸŽ ë°°ì—´ê³¼ idxë³€ìˆ˜ë¥¼ Queueì²˜ëŸ¼ ì‚¬ìš©í•˜ê¸°
```swift
func bfs(_ node: Int) -> Int {
    var bfsQueue = [Int](), idx = 0
    var visited = [Int](repeating: 0, count: N + 1)
    var count = 1
    visited[node] = count
    bfsQueue.append(node)
    while idx < bfsQueue.count {
        let number = bfsQueue[idx]; idx += 1
        for element in adjList[number] {
            if visited[element] != 0 { continue }
            count += 1
            visited[element] = 1
            bfsQueue.append(element)
        }
    }
    return count
}
```
