# 1325 효율적인 해킹

## 🍎 키워드
- 인접 리스트 설계
- DFS
- 최대값이 2개 이상일때 처리 방법 + 오름차순

## 🍎 문제 설계
- 지문에서 "이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다."를 보고 인접리스트가 생각났다.
- 예제 입력을 보자
```swift
5 4
3 1
3 2
4 3
5 3
```
- N = 5, M = 4
- 총 컴퓨터 숫자 5 어떤 컴퓨터가 어떤 컴퓨터를 신뢰하는지 알려주는 믿음 고리 4개(간선)
- 3 (이 컴퓨터가) 1 (이 컴퓨터를 신뢰)
- 3 (이 컴퓨터가) 2 (이 컴퓨터를 신뢰)
- 4 (이 컴퓨터가) 3 (이 컴퓨터를 신뢰)
- 5 (이 컴퓨터가) 3 (이 컴퓨터를 신뢰)
- X컴퓨터를 신뢰하는 컴퓨터들 Y를 아래와 같이 인접리스트로 표현할 수 있다.
- [1][3]
- [2][3]
- [3][4,5]

## 🍎 문제 해결
- N의 범위가 10,000이고 시간복잡도는 O(10000 * 9999)인 O(N^2)으로 잡았다
- 아래와 같은 경우가 생길 수 있기 때문에..
    - [1][2] -> 1번을 신뢰하는 2번 컴퓨터
    - [2][3] -> 2번을 신뢰하는 3번 컴퓨터
    - [3][4] -> 3번을 신뢰하는 4번 컴퓨터
    - [4][5] -> ...
    - [5][6] -> ...
    - [6][7] -> ...
    - [7][8]
    - [8][9]
    - [9][10]
    - [10][11]
    - [N][N+1]  -> N번을 신뢰하는 N+1번 컴퓨터
- 10000 * 10000? 브루트포스 레츠고!
- dfs를 이용해서 한 depth씩 들어갈때마다 해킹 숫자에 +1을 해준다.
- 숫자 하나하나 dfs를 통해서 값을 구하고 아래와 같이 해당 숫자를 인덱스로 값을 넣을수 있게 배열을 하나 만들어 주고 그 안에 값을 넣어준다.
```swift
for i in 1...N {
    clearVisited()
    let number = dfs(i)
    biggestList[i] = number
    biggestNum = biggestList[i] > biggestNum ? biggestList[i] : biggestNum
}
```
- biggestNum은 최대값을 갱신하는 변수이고 biggestList는 값들이 저장되는 배열이다.
- 위와 같은 코드는 최대값이 2개 이상일수도 있을때 사용한다.
- biggestList 배열에서 biggestNum과 같은 값을 가지는 모든 위치 출력
```swift
for i in 1...N {
    if biggestNum == biggestList[i] {
        print(i, terminator: " ")
    }
}
```

## 🍎 놓친 부분
- 처음엔 방문 배열을 사용하지 않고 풀었다.
- 다시 생각해보니, 예제 입력에는 나와있지 않지만 두 대의 컴퓨터가 서로 신뢰하고 있는 경우, 내가 사용한 로직이 정상적이지 않게 작동할 수 있어서 방문 배열을 사용했다.
- 예시
- [1][3]
- [3][1]
- 방문 체크를 안해주면 dfs 함수가 계속 실행되서 끝나지 않았을것.

## 🍎 최대값이 2개 이상일때 처리 방법 + 오름차순
```swift
for i in 1...N {
    clearVisited()
    let number = dfs(i)
    biggestList[i] = number
    biggestNum = biggestList[i] > biggestNum ? biggestList[i] : biggestNum
}

for i in 1...N {
    if biggestNum == biggestList[i] {
        print(i, terminator: " ")
    }
}
```
