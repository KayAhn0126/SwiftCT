# General

## 🍎 큰돌님 강의

## 🍎시간복잡도
- 문제에 주어진 범위와 메모리 제한 확인
    - 보통 문제에 주어진 범위는 입력에 대한 범위이다.
    - 만약 입력에 대한 범위가 아니라 logic에 사용될 어떤 배열의 범위가 1000만이다면 로직을 다시 생각해보자.(C++기준) -> 메모리 초과
- 재귀함수는 mainLogic x 함수 호출 횟수

## 🍎 누적합
### 📖 정의
- 누적합이란 요소들의 누적된 합의 의미
- 어떠한 배열을 기반으로 앞에서부터 요소들의 누적된 합을 저장해 새로이 배열을 만들어서 이를 활용하는것
- 앞에서부터 더하는 prefix sum (나옴)
- 뒤에서부터 더하는 suffix sum(나오지 않음)

### 📖 prefix sum(psum)
- 보통 psum(프썸)이라고 부른다.
- 배열을 생성할 때 0번째 인덱스에는 아무런 값을 넣지 않는다.
- 보통 배열은 0번째 인덱스부터 시작하지만, prefix sum배열을 만들때는 넣지 않는다.
- psum[1] = 1번째까지 합한것
- psum[2] = 2번째까지 합한것
- psum[3] = 3번째까지 합한것
- psum[4] = 4번째까지 합한것
- 
### 📖 예시문제
- 승철이는 뇌를 잃어버렸다. 학교에 갔더니 선생님이 자연수로 이루어진  N개의 카드를 주며 M개의 질문을 던진다. 그 질문은 나열한 카드 중 A번째부터 B번째까지의 합을 구하는 것이다. 뇌를 잃어버렸기 때문에 승철이는 이 문제를 풀 수 없다. 문제를 풀 수 있는 프로그램을 작성해보자.  
- 입력
    - 수의 개수 N, 합을 구해야 하는 횟수 M, 그 이후 N개의 수가 주어진다. 수는 100 이하의 자연수. 그 이후 M개의 줄에는 합을 구해야 하는 구간 A, B가 주어진다. 
- 출력
    - M개의 줄에 A부터 B까지의 합을 구하라. 
- 범위
    - 1 <= N <= 100,000
    - 1 <= M <= 100,000
    - 1 <= A <= B <= N
- 예제입력
    - 8 3
    - 1 2 3 4 5 6 7 8
    - 1 4
    - 1 5
    - 3 5
- 예제출력
    - 10
    - 15
    - 12
- 이문제를 무식하게 풀면 아래와 같이 for문으로 풀 수 있다.
```cpp
int a[100004], b, c, psum[100004], n ,m;
int main(){
    cin >> n >> m; 
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    for(int i = 0 ; i < m; i++){
        cin >> b >> c; 
        int sum = 0; 
        for(int j = b; j <= c; j++) sum += a[j];
        cout << sum << '\n'; 
    } 
    return 0;
}
```
- 위의 코드의 시간복잡도는 10만 * 10만 = 100억이라서 시간초과 발생.
- 이때 누적합을 써야한다. 또, 예시문제에서 입력을 보면 1부터 4, 1부터 5, 3부터 5까지 '어디서 부터 어디까지'라는 쿼리가 주어졌다.
- 이것을 '구간쿼리'가 주어졌다 라고 이야기 한다.
```cpp
int a[100004], b, c, psum[100004], n ,m;
int main(){
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n >> m; 
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        psum[i] = psum[i - 1] + a[i]; 
    }
    for(int i = 0 ; i < m; i++){
        cin >> b >> c; 
        cout << psum[c] - psum[b - 1] << "\n";
    } 
    return 0;
}
```
- psum[i] = psum[i-1] + a[i];
- 누적합을 만들때 반드시 1번째 요소부터!
    - i가 0이면 -1이 되기 때문.
- psum[c] - psum[b - 1]으로 해 구하기.

### 📖 어디서 부터 어디까지 구하라는 구간쿼리가 주어졌다면..
- 누적합(정적배열) or 펜윅트리(동적배열) 생각하기

## 🍎 구현
- 순서
    - 문제를 본다 (전체적으로)
    - 해석 (최대한 많은 시간 투자)
        - 최대, 최소 범위 파악
        - 단순 구현이면 구현
        - 무식하게 풀 수 있다면 무식하게 풀기 (완전 탐색(브루트 포스))
        - 다른 알고리즘
        - 제출하기 전 반례 생각하기
    - 코드를 작성


## 🍎 순열
- permutation
- 문제 풀기 전 오름차순 정렬 필수!
- nPr = n! / (n-r)!


## 🍎 조합
- combination
- nCr = nPr / r!


## 🍎 펜윅트리와 이분탐색
- 둘은 다른 알고리즘이지만 어떤 유동적인 배열에서 특정 요소를 logn만에 찾을수 있다.
- 하지만 펜윅트리는 무조건 새로운 배열을 만들어야 하고 이분탐색은 그렇지 않아도 된다.
- 만약  특정요소를 찾는 로직의 필요한 배열의 크기가 10,000,000(천만)이라면 새로운 배열을 만드는 펜윅트리 보다는 이분탐색을 사용하자
