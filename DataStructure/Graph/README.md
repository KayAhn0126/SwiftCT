# Graph

## 🍎 방향 그래프
### 📖 기본 개념
- 정점은 vertex, 간선은 Edge or directed Edge(방향이 있는 간선) or arc(방향이 있는 간선)
- 정점 u와 v가 있을때 암묵적으로 u는 from, v는 to로 통용된다.
![](https://i.imgur.com/pPRhfzF.png)
- v를 기준으로 outdegree = 3
- v를 기준으로 indegree = 2
- 방향에는 단,양방향이 있다.
### 📖 가중치란?
- 정점과 정점 사이에 드는 비용

## 🍎 무방향 그래프 (트리)
### 📖 기본개념
- 트리는 자식노드와 부모노드로 이루어진 계층적인 구조. 무방향 그래프의 일종이라 사이클이 없다.
![](https://i.imgur.com/o83mCcr.png)
- 정점은 vertex or node, 간선은 Edge라고 부른다.
- V - 1 = E (정점의 총 갯수 - 1 = 간선의 총 갯수) 

### 📖 트리 문제는 루트노드부터.
- 트리문제라면 루트노드로부터 DFS, BFS.

### 📖 트리의 높이와 깊이
![](https://i.imgur.com/kjGCrPJ.png)
- 트리의 높이는 루트노드부터 가장 긴 리프노드까지의 거리.
- 해당 이미지에서 트리의 높이는 3이다.
- 깊이는 각각의 노드마다 다르며 루트노드에서 특정 노드까지 최단거리로 갔을 떄의 거리이다. 위의 이미지에서 4번 노드의 깊이는 2이다.
- 레벨은 주어지는 문제마다 다르다 만약 루트가 level 0 이면 하위 노드들을 계층마다 +1. 문제마다 다르니 상황에 따라 유연하게.
- 숲(forest)는 트리로 이루어진 집합을 의미한다.

### 📖 트리의 종류
- 이진트리 (Binary Tree)
    ![](https://i.imgur.com/GO71RwF.png)
    - 각각의 노드의 자식노드 수가 2개 이하로 구성된 트리
    - 정 이진트리 : 자식노드가 0 또는 2개인 이진트리
    - 완전 이진트리 : 왼쪽부터 채워져있고 마지막 레벨을 제외하고는 모든 레벨이 채워진 트리
        - 위 이미지에서 완전 이진트리는 높이가 2이다. 즉, 마지막 이 이진트리의 마지막 레벨은 2이고 레벨 1이 모두 채워져있으므로 '마지막 레벨을 제외한 모든 레벨이 채워져있다'라는 조건을 성립한다.
    - 변질 이진트리 : 자식 노드가 하나밖에 없는 이진트리
    - 포화 이진트리 : 모든 노드가 꽉 차있는 이진트리
    - 균형 이진트리 : 트리 왼쪽의 가장 멀리 있는 리프노드와 오른쪽의 가장 멀리 있는 리프노드와의 높이 차이가 1인 이진트리
- 이진탐색트리 (Binary Search Tree)
    - 이진 트리의 일종이다.
    - 노드를 기준으로 왼쪽은 노드보다 작은값, 오른쪽은 노드보다 큰 값이다. 검색에 용이하다.
    - 탐색, 삽입, 삭제, 수정 모두 O(logN)
     ![](https://i.imgur.com/IDgo4y1.png)
    - 위의 이미지경우 N = 12이다 (노드가 12개) 무언가를 탐색한다고 했을때 O(logN)이 걸린다고 했으니 O(log12) ~ O(log16) = 4 
    - 12는 2의 몇제곱으로 표현하기 힘들어 2의 4제곱인 16으로 했다.
    - 즉, 최대 4번만에 찾을 수 있다는 이야기이다.
    - 이진 탐색 트리의 높이는 logN - 1이다.
    - 이진 탐색 트리는 삽입 순서에 영향을 받는다.
    ![](https://i.imgur.com/c55cSbQ.png)
    - 1,2,3을 순서대로 삽입하면 위 이미지와 같이 linear하게 되고 탐색의 시간복잡도는 O(logN)에서 O(N)으로 떨어지게 된다. 
    - 만약 1,2,3,4,5,6,7,8,9,10이 위의 이미지 처럼 linear하다면 루트 노드인 10에서 1까지는 O(N)인 10번이 걸린다.
- 균형잡힌 트리 (AVL트리, 레드 블랙 트리)
    - 삽입순서가 어떻게 되던지 트리의 노드를 회전시키는 방법을 통해 "균형잡히게 만든" AVL트리, 레드 블랙트리.
    - map이라는 자료구조는 삽입, 탐색, 삭제, 수정의 시간복잡도가 모두 O(logN)임을 보장받는데 그 이유는 map이 레드 블랙 트리를 기반으로 구현이 되어있기 때문이다.

## 🍎 정점과 간선의 집합을 코드로 표현하기
- 두가지 방법이 있다.
    - 인접 행렬
    - 인접 리스트
- 인접해있다 -> 연결이 되어있다.

### 📖 인접 행렬
- 2차원 배열로 구현.
- 그래프에서 정점과 간선의 관계를 나타내는 bool 타입의 정사각형 행렬.
- 정사각형 행렬의 각 요소가 0 또는 1이라는 값으로 정점 사이의 경로 유무를 판단할 수 있다.
- 무방향 그래프 := 양방향 그래프
![](https://i.imgur.com/pKtUyaW.png)
- 이 경우
```swift
adjMatrix[0][1] = 1,
adjMatrix[1][0] = 1,
adjMatrix[0][2] = 1,
adjMatrix[2][0] = 1,
adjMatrix[1][2] = 1,
adjMatrix[2][1] = 1,
adjMatrix[0][3] = 1,
adjMatrix[3][0] = 1
```
- 이렇게 하나하나 넣어주는 방법이 있고, 아래와 같이 한번에 선언하는 방법이 있다.
```swift
adjMatrix[4][4] = [
    [1, 1, 1, 1],
    [1, 1, 1, 0],
    [1, 1, 1, 0],
    [1, 0, 0, 1],
]
```
### 📖 인접 리스트
- 연결리스트(여러개)로 구현
![](https://i.imgur.com/ppBD9Bs.png)
- 각 정점마다 연결리스트를 만들고, 연결되있는 정점을 넣어준다.
```swift
[0][1,2,3]
[1][0,2]
[2][0,1]
[3][0]
```
- adj[4]라고 표현한다.
- adj[0]에 1,2,3을 요소로 넣어주면 된다.
- 스위프트에서는 [[Int]]로 구현해준다.

## 🍎 인접행렬과 인접리스트 중 무엇을 사용해야하나?
- 인접행렬은 구현이 쉽다. 하지만 간선의 개수에 비하여 노드의 개수가 많을 경우 탐색이 비효율적이다.
    - 노드의 숫자 20
    - 간선의 갯수 1개
    - 19-20
    - 이럴때 인접 행렬보다 인접 리스트가 좋다.

### 📖 공간복잡도
- 인접행렬 O(V^2)
- 인접리스트 O(V+E)

### 📖 시간복잡도 : 간선 한개 찾을때 
- u에서 v로 가는 간선 하나를 찾을때 시간복잡도 (최악)
- 인접행렬 O(1)
- 인접리스트 O(V)

### 📖 시간복잡도 : 모든 간선 찾을때
- 인접행렬 O(V^2)
- 인접리스트 O(V+E)

### 📖 그래프의 상태에 따라 다르다!
- 그래프가 희소(sparse)할 때는 인접행렬이 인접리스트보다 메모리를 더 많이 써야한다.
- 간선이 없어서 인접행렬의 대부분이 요소가 0인데도 간선을 표현하기 위해 2차원 배열을 만들어야 하기 때문이다.
- 반대로 그래프가 조밀(dense)할 때는 인접 행렬이 인접리스트 보다 좋다. 어차피 다 연결 되어 있기 떄문에 메모리적 효율성은 동일해지고 정점 i에서 정점j 까지의 간선이 있는지 확인하는 속도가 더 빠르기 때문이다.

## 🍎 문제가 지도로 주어지는 경우
### 📖 4방향
```swift
1  1  1          O - O - O
                 |   |   |
1  1  1     ->   O - O - O
                 | 
1  0  0          O   O   O
```
- 좌측이 문제이고 우측이 내가 생각해야하는 방식이다. 즉, 1은 갈 수 있는곳, 0은 갈 수 없는 곳이다.
- **지도가 주어지면 지도 기반으로 풀어야한다.**
- 보통은 4방향을 탐색하는 문제.
- 어떻게 4방향을 탐색할까?
![](https://i.imgur.com/Wr5vYJy.png)
- dy, dx의 d는 direction
- ny, ny의 n은 next
- 시계방향으로 dy,dx 정렬
- 8방향 탐색도 있다는것을 기억하자!

### 📖 탐색할때 조심해야 할 점
![](https://i.imgur.com/u2IEKzH.png)
- 인덱스의 언더플로우, 오버플로우는 continue
- 0(갈 수 없는 지역)은 continue
- 방문한 지역은 continue

## 🍎 연결된 컴포넌트
- 연결된 하위 그래프를 말하며 연결된 하나의 덩어리라고 생각하면 된다.
![](https://i.imgur.com/TeIR4ku.png)
- 위 그림에서 '연결된 컴포넌트'의 수는 총 3개이고 각각의 컴포넌트는 2개, 3개, 2개의 정점을 갖는다.
- 각각의 컴포넌트(덩어리)와 다른 컴포넌트(덩어리)를 연결하는 간선이 없으므로 독립적이다.
![](https://i.imgur.com/JnnbOon.png)
- 컴포넌트 각각에 id를 부여 or 색칠해서 구분하는것을 flood-fill 알고리즘이라고 한다.
- [플러드 필 알고리즘](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jh20s&logNo=221156150859)

## 🍎 DFS 깊이 우선 탐색
- 어떤 노드로 시작해 인접한 노드들을 재귀적으로 방문하여 **방문한 정점은 다시 방문하지 않으며 각 분기마다 가능한 가장 멀리 있는 노드까지 탐색**하는 알고리즘.

## 🍎 BFS 너비 우선 탐색
- 어떤 정점에서 시작해 다음 깊이의 정점으로 이동하기전 현재 깊이의 모든 정점을 탐색하며, 방문한 정점은 다시 방문하지 않는 알고리즘. -> 레벨별로 탐색한다!
- **같은 가중치를 가진 그래프에서 최단거리 알고리즘으로 사용한다!**
- FIFO 구조의 큐를 이용하자!

### 📖 시작지점이 다수라면..?
- 아래 그림 참고
![](https://i.imgur.com/bmHNpS6.png)
- 처음 큐에 enqueue하는 지점도 다수가 되어야 하며 해당 지점들의 visited를 모두 1로 만들면서 시작해야한다.

### 📖 가중치가 다른 그래프에서는..?
- BFS는 가중치가 같은 그래프 내에서 최단거리를 구할 때 사용하는 알고리즘이다.
![](https://i.imgur.com/beJfwXv.png)
- 위 이미지에서 보듯이 가중치가 달라 4번까지 최단거리는 1.5가 나와야 하지만 BFS로는 2로 나온다.
- **가중치가 다른 그래프 내에서 최단거리 알고리즘은 다익스트라, 벨만포드를 사용해야한다.**

## 🍎 DFS와 BFS 비교
- DFS와 BFS 모두 그래프를 탐색하는 알고리즘.
- 둘 다 시간복잡도는 인접리스트로 이루어졌다면 O(V+E)이고 인접 행렬의 경우 O(V^2)가 되는것은 동일하며 아래와 같은 차이점이 있다.

### 📖 DFS
- 메모리 덜 씀.
- 절단점(SCC)구현에 사용.
- 코드가 비교적 짧으며 완전탐색의 경우에 많이 사용

### 📖 BFS
- 메모리 더 씀 (무조건 queue가 필요하기 때문)
- 가중치가 같은 그래프내에서 최단거리를 구할 수 있음.
- 코드가 더 길다.

### 📖 정리
- 그래프만 탐색한다? -> DFS
- 최단거리 구해야한다? -> BFS

## 🍎 트리 순회
- 트리 순회는 트리 구조에서 각각의 노드를 정확히 한 번만 방문하는 과정을 말한다. 순회의 종류로는
    - 후위 순회
    - 전위 순회
    - 중위 순회
    - 레벨 순회가 있다.
- **보통 순회에 대해서 설명 할때는 이진트리를 기반으로 설명하지만 다른 모든 트리에서 일반화를 시킬 수 있다.**

### 📖 후위순회
- 자식들 노드를 방문하고 자신의 노드를 방문하는것.
![](https://i.imgur.com/pnYJWEH.png)
- 좌, 우, 자신 노드 순서

### 📖 전위순회
- 먼저 자신의 노드를 방문하고 그 다음 노드들을 방문하는것. DFS이다.
![](https://i.imgur.com/BvFqnHm.png)
- 자신 노드, 좌, 우 순서

### 📖 중위순회
- 왼쪽 노드를 먼저 방문 그 다음에 자신 노드, 그 다음 오른쪽 노드를 방문하는것.
![](https://i.imgur.com/OnRpQpZ.png)
- 좌, 자신 노드, 우 순서

### 📖 레벨순회
- BFS이다.
- 현재 레벨부터 각 레벨을 모두 순회하고 다음 레벨로 넘어간다.

## 🍎 Citation
- [큰돌 블로그](https://m.blog.naver.com/jhc9639/222289089015)
- [플러드 필 알고리즘](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jh20s&logNo=221156150859)
