# Graph

## 🍎 방향 그래프
### 📖 기본 개념
- 정점은 vertex, 간선은 Edge or directed Edge(방향이 있는 간선) or arc(방향이 있는 간선)
- 정점 u와 v가 있을때 암묵적으로 u는 from, v는 to로 통용된다.
![](https://i.imgur.com/pPRhfzF.png)
- v를 기준으로 outdegree = 3
- v를 기준으로 indegree = 2
- 방향에는 단,양방향이 있다.
### 📖 가중치란?
- 정점과 정점 사이에 드는 비용

## 🍎 무방향 그래프 (트리)
### 📖 기본개념
- 트리는 자식노드와 부모노드로 이루어진 계층적인 구조. 무방향 그래프의 일종이라 사이클이 없다.
![](https://i.imgur.com/o83mCcr.png)
- 정점은 vertex or node, 간선은 Edge라고 부른다.
- V - 1 = E (정점의 총 갯수 - 1 = 간선의 총 갯수) 

### 📖 트리 문제는 루트노드부터.
- 트리문제라면 루트노드로부터 DFS, BFS.

### 📖 트리의 높이와 깊이
![](https://i.imgur.com/kjGCrPJ.png)
- 트리의 높이는 루트노드부터 가장 긴 리프노드까지의 거리.
- 해당 이미지에서 트리의 높이는 3이다.
- 깊이는 각각의 노드마다 다르며 루트노드에서 특정 노드까지 최단거리로 갔을 떄의 거리이다. 위의 이미지에서 4번 노드의 깊이는 2이다.
- 레벨은 주어지는 문제마다 다르다 만약 루트가 level 0 이면 하위 노드들을 계층마다 +1. 문제마다 다르니 상황에 따라 유연하게.
- 숲(forest)는 트리로 이루어진 집합을 의미한다.

### 📖 트리의 종류
- 이진트리 (Binary Tree)
    - 각각의 노드의 자식노드 수가 2개 이하로 구성된 트리
    ![](https://i.imgur.com/GO71RwF.png)
    - 정 이진트리 : 자식노드가 0 또는 2개인 이진트리
    - 완전 이진트리 : 왼쪽부터 채워져있고 마지막 레벨을 제외하고는 모든 레벨이 채워진 트리
        - 위 이미지에서 완전 이진트리는 높이가 2이다. 즉, 마지막 이 이진트리의 마지막 레벨은 2이고 레벨 1이 모두 채워져있으므로 '마지막 레벨을 제외한 모든 레벨이 채워져있다'라는 조건을 성립한다.
    - 변질 이진트리 : 자식 노드가 하나밖에 없는 이진트리
    - 포화 이진트리 : 모든 노드가 꽉 차있는 이진트리
    - 균형 이진트리 : 트리 왼쪽의 가장 멀리 있는 리프노드와 오른쪽의 가장 멀리 있는 리프노드와의 높이 차이가 1인 이진트리

- 이진탐색트리 (Binary Search Tree)
    - 이진 트리의 일종이다.
    - 노드를 기준으로 왼쪽은 노드보다 작은값, 오른쪽은 노드보다 큰 값이다. 검색에 용이하다.
    - 탐색, 삽입, 삭제, 수정 모두 O(logN)
     ![](https://i.imgur.com/IDgo4y1.png)
    - 위의 이미지경우 N = 12이다 (노드가 12개) 무언가를 탐색한다고 했을때 O(logN)이 걸린다고 했으니 O(log12) ~ O(log16) = 4 
    - 12는 2의 몇제곱으로 표현하기 힘들어 2의 4제곱인 16으로 했다.
    - 즉, 최대 4번만에 찾을 수 있다는 이야기이다.
    - 이진 탐색 트리의 높이는 logN - 1이다.
    - 이진 탐색 트리는 삽입 순서에 영향을 받는다.
    ![](https://i.imgur.com/c55cSbQ.png)
    - 1,2,3을 순서대로 삽입하면 위 이미지와 같이 linear하게 되고 탐색의 시간복잡도는 O(logN)에서 O(N)으로 떨어지게 된다. 
    - 만약 1,2,3,4,5,6,7,8,9,10이 위의 이미지 처럼 linear하다면 루트 노드인 10에서 1까지는 O(N)인 10번이 걸린다.

- 균형잡힌 트리 (AVL트리, 레드 블랙 트리)
    - 삽입순서가 어떻게 되던지 트리의 노드를 회전시키는 방법을 통해 "균형잡히게 만든" AVL트리, 레드 블랙트리.
    - map이라는 자료구조는 삽입, 탐색, 삭제, 수정의 시간복잡도가 모두 O(logN)임을 보장받는데 그 이유는 map이 레드 블랙 트리를 기반으로 구현이 되어있기 때문이다.

## 🍎 정점과 간선의 집합을 코드로 표현하기
- 두가지 방법이 있다.
    - 인접 행렬
    - 인접 리스트
- 인접해있다 -> 연결이 되어있다.

### 📖 인접 행렬
- 2차원 배열로 구현.
- 그래프에서 정점과 간선의 관계를 나타내는 bool 타입의 정사각형 행렬.
- 정사각형 행렬의 각 요소가 0 또는 1이라는 값으로 정점 사이의 경로 유무를 판단할 수 있다.
- 무방향 그래프 := 양방향 그래프
![](https://i.imgur.com/pKtUyaW.png)
- 이 경우
```swift
a[0][1] = 1,
a[1][0] = 1,
a[0][2] = 1,
a[2][0] = 1,
a[1][2] = 1,
a[2][1] = 1,
a[0][3] = 1,
a[3][0] = 1 이라 표현한다.

a[4][4] = []
    [1, 1, 1, 1],
    [1, 1, 1, 0],
    [1, 1, 1, 0],
    [1, 0, 0, 1],
]
배열로는 이렇게 표현한다.
```
### 📖 인접 리스트
- 연결리스트(여러개)로 구현
![](https://i.imgur.com/ppBD9Bs.png)
- 각 정점마다 연결리스트를 만들고, 연결되있는 정점을 넣어준다.
```swift
[0][1,2,3]
[1][0,2]
[2][0,1]
[3][0]
```
- adj[4]라고 표현한다.
- adj[0]에 1,2,3을 요소로 넣어주면 된다.
- C++에서는 벡터로 사용했다.스위프트에서는 어떻게 구현해야 할까?


## 🍎 인접행렬과 인접리스트 중 무엇을 사용해야하나?
### 📖 공간복잡도
- 인접행렬 O(V^2)
- 인접리스트 O(V+E)

### 📖 시간복잡도 : 간선 한개 찾을때 
- u에서 v로 가는 간선 하나를 찾을때 시간복잡도 (최악)
-  인접행렬 O(1)
-  인접리스트 O(V)

### 📖 시간복잡도 : 모든 간선 찾을때
- 인접행렬 O(V^2)
- 인접리스트 O(V+E)

## 🍎 Citation
- [큰돌 블로그](https://m.blog.naver.com/jhc9639/222289089015)
