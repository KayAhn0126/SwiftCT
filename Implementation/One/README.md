# 4375 1

## 🍎 키워드
- 정수론 모듈러 연산
- 패턴 찾기
- 무한 입력 받기

## 🍎 정수론의 모듈러 연산 특징 (제일 중요!)
- **아래는 정수론의 모듈러 연산 특징이다**
- X mod N = (X mod N) mod N
- (X + Y) mod N = ((X mod N) + (Y mod N)) mod N (분배 법칙)

## 🍎 패턴 찾기
- 1 -> 11 -> 111 -> 1111 ...
- 1을 제외하고 11부터 111, 1111, 11111...이 되는 패턴을 보자
    - 11은 (1 * 10) + 1로 이뤄질 수 있다.
    - 111은 (11 * 10) + 1로 이뤄질 수 있다.
    - 1111은 (111 * 10) + 1
    - ...
- 1로만 이뤄진 수가 나중에는 Int의 범위를 넘어서는 경우도 생길 수 있다. -> 오버플로우
- X % N = (X % N) % N 또는 (X + Y) % N = ((X % N) + (Y % N)) % N
- 위의 두 특징을 보면 공통적으로 보이는것이 하나 있다.
- 마지막에 % N 하기 전에 중간에 한번 % N을 해줘도 값은 같다는 것이다.
- 이제 분배 법칙을 적용해보자
- (num * 10 + 1) % N = ((num % N) * (10 % N) + (1 % N)) % N
    - 중간에 한번 N으로 나눈 나머지를 구했다.
- N = 3일때 시뮬레이션을 해보자
    - num = (1 * 10 + 1) % 3
        - 즉 num = ((1 % 3) * (10 % 3) + (1 % 3)) % 3 
        - num = (1 * 1 + 1) % 3
        - num = 2
    - num = (2 * 10 + 1) % 3
        - 즉 num = ((2 % 3) * (10 % 3) + (1 % 3)) % 3 🔥
        - num = (2 * 1 + 1) % 3
        - num = 0
        - 끝
    - 🔥이 있는 라인을 보면 사실 저 부분은 ((11 % 3) * (10 % 3) + (1 % 3)) % 3이 되어야 한다고 생각이 든다. 근데 왜 11 대신에 2가 들어있는것일까?
    - 🔥 라인에 2를 어디서 구했는지 생각해보면 11 % 3의 결과 값이다
        - 값이 커지기 전에 미리 나머지 연산을 했다.
    - 미리 나머지를 구했으니 다시 % 3을 하면 안되는거 아닌가?
    - 모듈러 연산의 특징에서 X % N = (X % N) % N과 같으니...
    - (2 % 3) == ((11 % 3) % 3) 이렇게 식을 만들 수 있다.
- 포인트는 나머지 분배법칙 사용과 이미 나머지가 구해진 수를 한번 더 N으로 나눌수 있다는것.
- 다시 보고 이해가 안되면 "중간에 한번 나눈다. + 분배법칙"을 잘 생각해보자.
```swift
while let number = readLine() {
    let N = Int(number)!
    if N == 1 {
        print("1")
    } else {
        var count = 1
        var num = 1
        while num != 0 {
            num = (num * 10 + 1) % N
            count += 1
        }
        print(count)
    }
}
```

## 🍎 도움받은 글
[백준 11726과 11727에서 10007로 나누는 과정](https://www.acmicpc.net/board/view/20220)
