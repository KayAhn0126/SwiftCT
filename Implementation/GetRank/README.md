# 1205 등수 구하기
- 구현

## 🍎 지문 해석
- 매번 게임할 때 마다 얻는 점수가 내림차순으로 저장된다.
- 랭킹 리스트는 보통 위에서부터 몇 번째 있는 점수인지로 결정한다. 
- 예를 들어 랭킹 리스트가 100, 90, 90, 80일 때 각각의 등수는 1, 2, 2, 4등이 된다. 하지만, **같은 점수가 있을 때는 그러한 점수의 등수 중에 가장 작은 등수가 된다**. **만약 점수가 랭킹 리스트에 올라갈 수 없을 정도로 낮다면 -1을 출력한다.**
    - 이 부분은 예제를 통해서 알아보자.
    - 10 1 10
    - 10 9 8 7 6 5 4 3 2 1 라면,
    - 10개의 숫자가 주어지고, 태수의 숫자는 1, 랭킹은 10등까지 카운트 하겠다는 의미다.
    - 10 -> 1등
    - 9 -> 2등
    - ...
    - 2 -> 9등
    - 1 -> 10등
    - 1 -> 10등
    - 랭킹은 10등까지 카운트 하겠다고 했고, 같은 점수 등수 중 더 작은 등수가 된다고 했다. 이때 마지막 1이 10등이고 그 다음 1이 태수의 랭킹이다. 즉 이 예제에서 태수는 랭킹 리스트에 올라갈 수 없을 정도로 낮아 -1을 받는다.

## 🍎 문제 접근
- 태수의 점수를 미리 arr에 추가.
- 내림차순으로 정렬
- rank 배열을 만들고 모든 값을 1로 초기화
    - 2중 for문을 순회하면서 앞에 있는 숫자(들)이 나보다 확실히 크다면 값을 올려준다.
- 이제 각 숫자에 대한 rank도 구했으니 태수의 점수가 랭킹 리스트 안에 들어가는지 확인 해야한다.
    - 태수의 점수 또는 태수의 점수와 동일한 점수들 중 배열에서 처음으로 나오는 인덱스를 찾는다.
    - 태수의 점수가 배열에서 처음으로 나오는 인덱스와 배열에서 해당 점수의 총 갯수를 더해서 랭킹 리스트를 넘으면 태수의 점수는 -1이 되고, 그것이 아니라면 태수는 랭킹 리스트 안에서 자신에게 주어진 랭킹을 받는다.

## 🍎 문제 풀이 및 전체 코드
```swift
import Foundation

let NMP = readLine()!.split(separator: " ").map { Int(String($0))! }
let N = NMP[0] // 주어지는 숫자의 개수
let M = NMP[1] // 태수의 새로운 점수
let P = NMP[2] // 랭킹 리스트에 올라 갈 수 있는 점수의 개수

var result = 0
if N > 0 {
    var arr = readLine()!.split(separator: " ").map { Int(String($0))! }
    arr.append(M)
    arr.sort(by: >)
    var rank = [Int](repeating: 1, count: N + 1)
    for i in 0..<N+1 {
        for j in 0..<i {
            if arr[j] > arr[i] {
                rank[i] += 1
            }
        }
    }
    
    // 태수의 점수 또는 태수와 같은 점수들이 배열에서 처음으로 나오는 곳의 인덱스를 구한다.
    let firstIndexOfM = arr.firstIndex(of: M)!
    
    // 태수의 점수가 배열에서 총 몇개나 있는지 구한다.
    let count = arr.filter { $0 == M }.count
    
    // 배열에서 태수의 점수가 처음나오는 위치와 총 갯수를 더했을때 P를 넘어가면,
    // 태수는 랭킹 리스트에 들지 못했으므로 -1을 받고, 그것이 아니라면 랭킹 리스트에 적힌 등수를 얻는다.
    if firstIndexOfM + count > P {
        result = -1
    } else {
        result = firstIndexOfM + 1
    }
} else {
    result = 1
}
print(result)
```
