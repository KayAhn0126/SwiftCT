# 2579 계단 오르기
- bottom up

## 🍎 문제 접근
- 제약 조건
    - 계단은 한번에 한 계단 or 두 계단씩.
    - 연속된 세 개의 계단은 안된다.
    - 마지막 도착 계단은 반드시 밟아야 한다.
- 처음에 top-down을 구현을 시도했다. 하지만 "**마지막 도착 계단을 반드시 밟아야 한다**"라는 조건을 어떻게 만족시켜야 할지 감이 안와서 bottom - up으로 풀었다.

## 🍎 문제 풀이
![](https://i.imgur.com/wO50vTd.png)
- 어떤 계단 X의 입장에서 이 문제를 바라보자.
- X의 계단에 왔을때 저장되어야 하는 값은 특정 조건을 만족하는 수들 중에서 가장 큰 수가 되어야 한다.
- 결국 구해야 하는것은 "주어진 조건을 만족하면서 N번째 계단까지 올라갔을때, 구할 수 있는 최대의 값"이다.
    - 이것을 dp[N]에 담을것이다.
- 처음부터 올라가보자!
- 0번째 계단까지 왔을때 최고의 수는 0이다.
    - dp[0] = 0
- 1번째 계단까지 왔을때 최고의 수는 max(0번째 수, 1번째 수)
    - dp[1] = arr[1] // 10이다.
- 2번째 계단까지 왔을때 최고의 수는 max(0번째 수 + 1번째 수, 1번째 수 + 2번째 수)
    - dp[2] = arr[1] + arr[2] // arr[0]은 0이기 때문에!
- 이제 3번째 부터 다른 로직이 적용되는데..
```swift
for i in 3...userInput {
    dp[i] = max(dp[i-2] + arr[i], dp[i-3] + arr[i-1] + arr[i])
}
```
- 마지막 계단을 무조건 밟고, 연속된 세 개의 계단을 밟으면 안된다면 아래 두 가지 케이스가 존재한다.
    - ① (마지막 계단 + 전전 계단)을 밟는 경우
    - ② (마지막 계단 + 전 계단 + 전전전 계단)을 밟는 경우
- 이 덕분에 세 개 계단을 연속으로 밟는 경우가 없어진다.

## 🍎 전체 코드
```swift
import Foundation

let userInput = Int(readLine()!)!

var arr = [Int](repeating: 0, count: userInput + 1)

for i in 1...userInput {
    arr[i] = Int(readLine()!)!
}

var dp = [Int](repeating: 0, count: userInput + 1)
// 각 자리에 왔을때 현재 자리까지 가장 큰 값을 넣어준다

if userInput <= 1 {
    dp[0] = arr[0]
    dp[1] = arr[1]
    print(dp[userInput])
} else if userInput == 2 {
    dp[2] = arr[1] + arr[2]
    print(dp[userInput])
} else {
    dp[0] = arr[0]
    dp[1] = arr[1]
    dp[2] = arr[1] + arr[2]
    /**
     - 첫 번째 계단까지는 (첫 번째 계단)이 최댓값이다.
     - 두 번째 계단까지는 (첫 번째 계단 + 두 번째 계단) 혹은 (두 번째 계단) 중 하나가 최댓값이다.
     - 세 번째 계단까지는 (첫 번째 계단 + 세 번째 계단) 혹은 (두 번째 계단 + 세 번째 단계) 중 하나가 최댓값이다.
     */
    
    for i in 3...userInput {
        dp[i] = max(dp[i-2] + arr[i], dp[i-3] + arr[i-1] + arr[i])
    }
    /**
    마지막 계단을 무조건 밟고, 연속된 세 개의 계단을 밟으면 안된다면 아래 두 가지 케이스가 존재한다.
    ① (마지막 계단 + 전전 계단)을 밟는 경우
    ② (마지막 계단 + 전 계단 + 전전전 계단)을 밟는 경우
    - 이 덕분에 세 개 계단을 연속으로 밟는 경우가 없어진다.
    */
    print(dp[userInput])
}
```
