# 14501 퇴사
- DP로 풀었지만 DFS로도 풀 수 있다고 한다.
- na982님의 강의를 보고 문제 해결 (top - down)
- 문제를 꼼꼼하게 읽자
    - 마지막날에 1일이 걸리는 일을 할 수 있나? -> 있다!
        - 7일이 마지막 날이라고 하면, 7일에서 1일이 걸리면 7일에 끝나고 8일에는 일이 없는것이다.
    - 마지막날에 2일이 걸리는 일을 할 수 있나? -> 없다.
        - 마찬가지로 7일이 마지막 날이라고 하면, 7일도 일해야하고, 퇴사날인 8일도 일해야 하기 때문에 불가능하다.

## 🍎 문제 접근
### 📖 완전 처음 접근 했을때.
- 완전히 처음에 문제를 접했을때는 그리디하게 현재 위치에서 가장 가까운 일을 골라서 수행했다.
- 문제의 예제 입력 4를 보자
```bash
10
5 50 - 1일
4 40
3 30
2 20
1 10
1 10 - 6일
2 20 - 7일
3 30 - 8일
4 40
5 50 - 10일
```
- 1에서 부터 10일까지 매 일마다 걸리는 시간과 보수가 나와있다.
- 만약 이것을 그리디하게 푼다면 1일,6일,7일이 되어서 80원을 벌 수 있다.
- **하지만 6일이 되었을 때, 7일을 쉬고 8일에 다시 일을 하게된다면 10일동안 총 90원을 벌 수 있다.**

### 📖 두번째 접근
- 다시 문제를 읽고 언제 일을 하던지 퇴사 전 **돈만 많이 벌면 되는 로직으로 구현**해야 한다는것을 알 수 있다.
- 도저히 구현 방법이 떠오르지 않아 na982님의 유튜브를 참고했다.
- 오늘 일을 했을때와 오늘 일을 하지 않았을때를 재귀식으로 구하면서 구해진 값은 dp에 넣는 방식으로 풀면 된다는 것을 알았다.

## 🍎 문제 풀이
![](https://i.imgur.com/ya8vI5p.png)
- na982님의 유튜브에서 가져온 이미지.
- na982님은 백준에 나와있는 예제 1일부터 7일을, 0일부터 6일로 표시했다.
    - 즉 위 이미지에서는 마지막 날은 6일이고 7일이 실제로 백준이가 퇴사하는 날이라는것
    - 이미지를 보면 7일은 0으로, 8일은 -987654321로 값이 설정되어있는것을 볼 수 있는데,
    - 7일이 0인 이유를 생각해보자. 만약, 백준이가 6일에 상담을 하는데 걸리는 시간이 1일이라고 하면 6일 전체를 소모하고 7일에는 깔끔하게 퇴사할 수 있다.
    - 즉 우리가 세운 점화식 특성상 7일에 도달할 수 있는데, 그때 7일을 0으로 두면 더 이상 계산을 하지 않고 식이 여기서 끝난다.

### 📖 생각해야 하는것
- 내가 백준이가 되었다고 생각해보자.
- 나는 오늘부터 일을해서 N일 전까지 매일 일하건 띄엄띄엄 일을 하건, 무조건 돈을 최대한 많이 벌기만 하면된다.
    - 최대값을 구하기만 하면 되기 때문에 꼭 꽉차게(그리디하게) 일을 할 필요는 없다.
- 오늘 일을 했을때와 오늘을 스킵 했을 때, 둘 중 큰 값을 출력하면 된다.

### 📖 점화식
- 간잽이 백준이가 사용할 점화식은 아래와 같다
```swift
solve(day) = max(solve(day + T[day]) + P[day], solve(day + 1))
```
- 점화식을 풀어서 이해해보자.
- 오늘의 상담을 하는 경우
    - solve(day + T[day]) + P[day]
    - 오늘 상담 했기 때문에 (현재 날 + 걸리는 날)의 날짜로 가서 다시 점화식 수행
    - 상담 했으므로 보수 P[i] 추가
- 오늘의 상담을 하지 않는 경우 
    - solve(i + 1)
    - 오늘 상담 하지 않으면 간단하게 다음날로 넘기면 된다.
- 큰 그림에서 보면,
    - **오늘 일을 했을때 수익**
    - vs
    - **오늘 일을 건너 뛰었을 때 수익**
    - 중 큰 값을 출력하면 된다.


## 🍎 전체코드 및 풀이
```swift
import Foundation

let number = Int(readLine()!)!
var result = 0

//MARK: 0 ~ number - 1 인덱스 기반
var tArr = [Int](repeating: 0, count: number + 1)
var pArr = [Int](repeating: 0, count: number + 1)

var dp = [Int](repeating: -1, count: 16)

// 1일차 부터 N일차 까지 '해당 일차를 상담했을때 걸리는 시간'을 tArr에, '보수'를 pArr에 넣어준다.
for i in 1...number {
    let tp = readLine()!.split(separator: " ").map { Int(String($0))! }
    let day = tp[0]
    let pay = tp[1]
    tArr[i] = day
    pArr[i] = pay
}
func solve(_ day: Int) -> Int {
    // 첫번째 기저 사례
    if day > number + 1 { return -999999999 } 
    // 두번째 기저 사례
    if day == number + 1 { return 0 } // 백준이가 퇴사하는 당일은 0으로 두어서 더 이상 재귀를 진행시키지 않도록 한다.
    dp[day] = max(solve(day + tArr[day]) + pArr[day], solve(day + 1))
    // 오늘 상담을 했을때 최대 수익과, 오늘 상담을 하지 않고 내일부터 상담을 시작했을때 수익을 비교한다.
    // 내일부터 상담을 시작하면 또 다시 내일 vs 내일을 건너뛰고 사흘부터 상담을 시작했을때의 수익을 비교한다.
    // 백준의 1번 예제를 통해 위의 기저사례가 왜 있는지 알아보자
    // 백준이는 8일에 무조건 퇴사를 해야한다. 

    // 첫번째 기저 사례
    // 만약 백준이가 7일에 일을 하려고 하는데 상담시간이 2일이라면 7,8일에 일을하고 9일에 퇴사를 해야한다.
    // 8일에 무조건 퇴사를 해야하는 백준이 입장에서는 7일 상담을 아예 진행 할 수 없다.
    // 이것을 코드로 어떻게 만들까? -> 재귀 함수를 멈추는 방법은 기저 사례 뿐이다.
    // 즉 상담이 백준이의 퇴사 날자를 넘기게 진행이 되면 -999999999를 리턴해서 최대값을 만들 수 없게 만들어준다.
    // 최댓값을 만들어 주지 않는 행동은 최대값을 찾는 문제에서 "이 작업은 의미가 없다"라는 것과 같은 의미이다.

    
    // 두번째 기저사례
    // 백준이 퇴사 전날인 7일에 상담시간이 1일이라면 7일에도 일을 할 수 있다는 뜻이다.
    // 그럼 max(solve(7+1) + 7일까지 쌓아온 금액 vs solve(7+1)일(0원))이 되고 딱 백준이가 퇴사하는 날까지 깔끔하게 계산 할 수 있다. 
    // 0을 리턴하는 의미는 8일에 "일을 하지 않고 문제없이 퇴사했다."라는 의미이다.
    return dp[day]
}

print(solve(1))
```
