# 11053 가장 긴 증가하는 부분 수열
- LIS
- 시간복잡도 N^2
- 현재는 범위가 1000이지만 100만 단위가 나오면 nlogn을 알고리즘 공부 필요

## 🍎 문제 접근
- LIS 가장 기본 문제.
- 만약 A = {10, 20, 10, 30, 20, 50}인 경우 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다
- 이것을 어떻게 구할까?
- 각 위치마다 해당 위치까지의 LIS를 구한다.
    - 즉 dp 배열에 저장되는 값은 해당 위치까지 LIS의 길이이다.
- 먼저 가장 긴 증가하는 부분 수열의 가장 중요한 조건을 보자.
    - 현재 숫자가 앞의 숫자보다 커야한다.
    - 나머지는 아래의 코드에서 설명.

## 🍎 문제 해결
```swift
for i in 0..<arr.count { // i를 순회 시키면서
    var latest = 0
    for j in 0..<i { // 0 부터 i -1까지 비교하는 반복문을 돌린다.
        if arr[j] < arr[i] && latest < dp[j] {
            latest = dp[j]
        }
    }
    dp[i] = latest + 1
    result = dp[i] > result ? dp[i] : result
}
```
- 주어진 배열 10, 20, 10, 30, 20, 50에서 가장 긴 증가하는 부분 수열을 구해보자.
- 이것을 dp 배열의 변화와 함께 보자.
- 내부 for문을 돌기 전, latest는 항상 0으로 초기화한다.
- arr = 10 20 10 30 20 50
- i가 0일때, 내부 for문은 아예 돌지 않는다 그래서 dp[0] = 0 + 1 = 1
- 현재 dp = 1 0 0 0 0 0
- i가 1일때, 내부 for문은 한번만 수행된다(j가 0인 경우)
    - 이때, arr[0] < arr[1] && latest < dp[j] 조건이 참인지 확인한다.
        - 10 < 20 && 0 < 1 으로 될수 있고 이 조건은 곧 참이 된다.
        - 조건이 참이므로 if문 실행 -> latest = 1
    - dp[1] = 1 + 1 = 2
- 현재 dp = 1 2 0 0 0 0
- i가 2일때, 내부 for문은 두번 수행된다(j가 0일때, j가 1일때)
    - 먼저 j가 0일때, arr[0] < arr[2] && latest < dp[0] 조건이 참인지 확인한다.
        - 10 < 10 && 0 < 1 이므로 참이 될 수 없다!
    - 이제 j가 1일때, arr[1] < arr[2] && latest < dp[1] 조건이 참인지 확인한다.
        - 20 < 10 && 0 < 2 이므로 참이 될 수 없다!
    - 조건이 모두 거짓이라 if문이 한번도 실행되지 않음.
        - 즉, latest가 한번도 바뀌지 않았으므로, dp[2] = 0 + 1 = 1
- 현재 dp = 1 2 1 0 0 0
- i가 3일때, 내부 for문은 세번 수행된다(j가 0일때, j가 1일때, j가 2일때)
    - j가 0일때, arr[0] < arr[3] && latest < dp[0] 조건이 참인지 확인한다.
        - 10 < 30 && 0 < 1 이므로 참이 된다.
        - 조건이 참이므로 if문 실행 -> latest = 1
    - j가 1일때, arr[1] < arr[3] && latest < dp[1] 조건이 참인지 확인한다.
        - 20 < 30 && 1 < 2 이므로 참이 된다.
        - 조건이 참이므로 if문 실행 -> latest = 2
    - j가 2일때, arr[2] < arr[3] && latest < dp[2] 조건이 참인지 확인한다.
        - 10 < 30 &&  2 < 1 이므로 참이 될 수 없다!
        - latest는 그대로 2
        - 이 경우를 보면 이전 숫자가 현재 숫자보다 작지만 그렇다고 바로 업데이트를 시켜주는것이 아니라는 것을 알 수 있다.
        - 이전 숫자가 현재 숫자보다 작으면서 또, 최대 증가 길이 또한 지금까지 최대값 만을 저장해온 latest 보다 커야 "증가하는 순열"이라는 것이 증명되기 때문이다.
    - dp[3] = 2 + 1
- 현재 dp = 1 2 1 3 0 0
- 이런식으로 dp를 구하다보면
- 마지막 dp = 1 2 1 3 2 4로 마무리 된다.

