# Two Pointer
## 🍎 개념 설명
- 두개의 포인터를 이용해 문제를 해결하는 알고리즘
    - left와 right 변수를 인덱스로 활용
- O(n^2) 솔루션을 O(n)으로 성능 향상 가능
- **연속된 구간의 원소들을 처리하기 원하거나, 정렬된 배열에서 무언가를 구할 때 투 포인터 사용**

## 🍎 투 포인터 문제 유형

### 📖 원소들의 합이 X인 연속 부분 배열의 개수 구하기
- 입력
    - 배열 = [1,3,6,5,2,7,9], X = 9
- 출력
    - 3
    - (3,6), (2,7), (9)
- 이 경우 현재 배열의 순서가 답에 영향을 미치므로 배열을 정렬하면 안된다!

### 📖 두 수를 골랐을때 (같은 수일 수도 있다), 그 차이가 M 이상이면서 제일 작은 경우 구하기
- [수 고르기](https://www.acmicpc.net/problem/2230)
- 입력
    - 총 갯수 N = 5
    - 배열 = [1,3,2,7,5], M = 3
- 이 경우는 정렬이 필요하다! 왜?
    - 투 포인터 알고리즘은 left와 right를 움직이면서 값을 찾아나가는데, 위와 같이 정렬이 되어있지 않은 배열은 left와 right를 이동할때 기반이 되는 근거가 없다.
    - 즉, 포인터를 이동할 때, 현재의 왼쪽이나 오른쪽에 어떤 수가 있는지 모르니 포인터가 이동할 수 없다는 이야기다.
- 위의 설명이 어렵다면 정렬된 배열을 예로들어 이해해보자.
    - 총 갯수 N = 5
    - 배열 = [1,2,3,5,7], M = 3
    - result = Int.max
    - l,r 모두 왼쪽에서 시작하고 두 값의 차이는 arr[right] - arr[left]로 표현한다.
    - left = 0, right = 0일때,
        - 1 - 1 = 0, 두 수의 차이가 3보다 작으므로 right를 하나 올려준다.
        - 2 - 1 = 1, 두 수의 차이가 아직도 3보다 작으므로 right를 하나 더 올려준다.
        - 3 - 1 = 2, 두 수의 차이가 아직도 3보다 작으므로 right를 하나 더 올려준다.
        - 5 - 1 = 4, 처음으로 두 수의 차이가 3보다 커짐으로 값 비교 후 4를 저장한다. 3차이가 나는 다른 수를 찾기 위해 left를 하나 올려준다. 
    - 위와 같은 로직으로 left와 right가 이동할 수 있는것은 현재 숫자의 오른쪽에는 항상 현재 수 보다 큰 수가 있다는 것이 보장되어 있기에 가능하다.

### 📖 서로 다른 양의 정수가 x를 만족하는 경우의 수 구하기
- [두 수의 합](https://www.acmicpc.net/problem/3273)
- 5 12 7 10 9 1 2 3 11 배열이 주어지고 두 수를 합해서 13을 만들수 있는 경우의 수를 구하면 된다.
- 배열의 순서가 중요한 문제인가?
    - 현재 배열처럼 정렬되지 않은 상태에서는 포인터를 어떤 방식으로 움직여야하는지에 대한 로직이 없다.
    - 즉, 정렬이 필요하다.
