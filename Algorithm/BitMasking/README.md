# Bit Masking

## 🍎 비트마스킹
- Bool 배열의 역할을 하는 "하나의 숫자"를 만들어서 "비트 연산자"를 통해 탐색, 수정등의 작업을 하는 것을 비트마스킹 이라고 한다.
- 알아둘 점
    - 이진수 S에서 비트의 인덱스는 오른쪽부터 0이다.
    - 방문 배열로 사용 할 경우 범위가 30 이하인지 생각하자!
## 🍎 비트마스킹 빠르게 사용하기
- 선언
```swift
var S: Int = (1 << 26)
```
- idx번째 비트를 켜기
```swift
S |= (1 << idx)
```
- idx번째 비트 끄기
```swift
S &= ~(1 << idx)
```
- idx번째 비트 XOR 연산
```swift
S ^= (1 << idx)
```
- idx번째 비트가 켜져있는지 확인하기
```swift
S & (1 << idx)
// 아래와 같이 사용한다. 무조건 0이 아닌지 확인해야한다. (자세한 내용은 아래 설명 확인)
if visited & (1 << board[ny][nx]) != 0 { continue }
```
- 최하위 켜져있는 비트 찾기
```swift
idx = (-S & S)
// -S는 어떻게 구하지? 
// ~S = -(S + 1), 즉 -S = ~S + 1
```
- 크기가 n인 집합의 모든 비트 켜기
```swift
(1 << n) - 1
```

## 🍎 조금 더 자세히 알아보기 + 원리
### 📖 왼쪽, 오른쪽 쉬프트 연산자
- 왼쪽 쉬프트 연산자
- a << b = a * 2^b
- 예제.
    - 2진수 111은 7이다
    - 2진수 111을 한번 왼쪽 쉬프트 하면,
    - 111 << 1 으로 표현 할 수 있고
    - 2진수 1110이 된다. 즉, 14가 된다.
    - 2진수 1110을 다시 한번 왼쪽 쉬프트 하면 어떻게 될까?
    - 2진수 0001 1100이 된다 -> 28(10진수)
    - 왼쪽으로 한칸씩 옮길수록 이전 값의 2배가 된다.
    - 또는 111 << 2 로 28을 만들 수 있다.
- 오른쪽 쉬프트 연산자
- a >> b = a * (1/2)^b
- 예제
    - 11 >> 2 = 11 * (1/2)^2
    - 11을 이진수로 나타내면 1011
    - 여기서 오른쪽으로 두칸가면
    - 0010
    - 0010은 10진수로 2

### 📖 비트마스킹에서의 쉬프트 연산자
- 비트마스킹이라고 하면 보통은 7 << 2 이런 형태가 아닌 1을 많이 사용한다.
- 1 << b 형식으로 사용한다.
- 1 << 4는 뭘까? -> 4번만큼 왼쪽으로!
    - "1 0000"으로 된다.
    - 16

### 📖 XOR 연산자 (^) 
- 같은건 싫어! -> 달라야 true!
- 예제
    - 1001(9) ^ 1000(8)는..
    -    1001 (9)
    - ^  1000 (8)
    -    0001 <- XOR한 값 1
- 예제
    - 1001(9) ^ 1010(10)은..
    -    1001 (9)
    - ^  1010 (10)
    -    0011 <- XOR한 값 3

### 📖 one's completion (~)
- 기억하기 **~S = -(S + 1)** 또는 **-S = ~S + 1**
- weird 연산자라고도 불린다.
- 1의 보수 연산자
    - 비트를 반전 시키는 연산자
- 예제
    - **두 방식으로 사용 될 수 있다.**
    - 첫째, 이진수에 weird 연산자를 붙이면 비트 반전.
        - 10010 -> 01101
        - 즉, 0001 0010이 반전이 되어서 1110 1101이 된다.
    - 둘째, 10진수에 weird 연산자를 붙이면 해당 값을 마이너스로 바꾼후 + 1
    - ~3은 = -(3 + 1)과 같다.

### 📖 idx번째 비트 끄기
- 기억하기 S &= ~(1 << idx)
    - 여기서 S는 이진수 Something.
    - 바꾸려는 이진수 S와 S에서 끄고싶은 위치 idx를 이용해 비트를 끌 수 있다.
    - S & ~(1 << idx)
- 예제
    - S = 10010(18) 여기서 1번째 비트(1)을 끄고 싶다!
    - 1 << idx, 즉 1 << 1이 되고 이것은 00010이 된다.
    - 여기서 00010을 반전 시키면 11101이 된다
    - 이 두 값을 & 연산하면 된다.
    - 그럼 아래와 같이 연산이 된다.
    -    10010 -> S
    - &  11101 -> ~(1 << 1)
    -    10000 <- 1번째 인덱스의 비트가 꺼진것을 볼 수 있다.

### 📖 idx번째 비트 XOR 연산
- 기억하기 S ^= (1 << idx)
- idx번째 비트 toggle
- 10010 (18)에서 0번째 비트를 토글하고 싶다!
    - 만약 0번째 비트가 0이면 1로, 1이면 0으로 바꾸고 싶다!
    - S = 10010 (18)
    - 1 << idx, 즉 1 << 0이 되고 이것은 00001이 된다.
    - 이제 두 값을 XOR 연산.
    -    10010 -> S
    - ^  00001 -> (1 << 0)
    -    10011 -> 0번째 인덱스의 비트가 toggle된것을 볼 수 있다.

### 📖 최하위 켜져있는 비트 찾기
- 최하위 켜져있는 비트의 인덱스는.. 아래와 같이 찾는다.
    - 기억하기 **idx = (-S & S)**
    - -S는 어떻게 구하지? 
        - ~S = -(S + 1), 즉 -S = ~S + 1
        - 현재 S는 2진수이니 비트 반전을 해주고 비트에 0001을 더해주면 된다.
    - S가 10010이라면 
        - ~S = 01101이고 여기에 1을 더해주면
        - 01101 + 0001 -> -S 완성! -> 01110
    - 이제 -S와 S를 & 연산 해주면 된다.
    -    10010
    - &  01110
    -    00010 -> **1번 인덱스가 최하위 켜져있는 비트의 인덱스!**
- 10010에서 최하위 켜져있는 비트는 1번 인덱스의 1이다.

### 📖 크기가 n인 집합의 모든 비트 켜기
- 기억하기 S의 길이가 n 일때,
    - (1 << n) - 1
- 우리가 비트연산 등 그러한 과정을 배웠던 이유는 Bool 타입의 배열을 대신하기 위해서다!
- n = 4
    - 4비트를 모두 켰을때 값을 구하는 공식은
    - (1 << n) - 1 이다. 여기서 n은 비트의 길이
    - 1 << 4 = 1 0000 = 16 - 1 = 15
    - 즉, 이진수 1111은 15이다.

### 📖 idx번째 비트를 켜기
- 기억하기 S |= (1 << idx)
- 예제
    - 이진수 S는 10010(18)이고 여기에서 0번째 인덱스의 비트를 켜고 싶다.
    - 1 << 0 = 0001
    - S와 OR 연산
    -    10010 -> S
    - |  00001 -> (1 << 0)
    -    10011 -> 0번째 인덱스가 켜진것을 볼 수 있다.

### 📖 idx번째 비트가 켜져있는지 확인하기
- 기억하기 S & (1 << idx)
- S = 10010(18)
- 만약 S의 3번째 인덱스의 비트가 켜져있는지 확인하고 싶다!
    - S = 10010
    - 1 << 3 -> 1000
    - 이제 & 연산을 하면,
    -    10010
    - &  01000
    -    00000 -> 즉, S의 3번째 인덱스의 비트는 꺼져있다!
- 다른 예제를 들어보자! S의 4번째 인덱스의 비트가 켜져있는지 확인하고 싶다!
    - S = 10010
    - 1 << 4 -> 1 0000
    - 이제 & 연산.
    -    10010
    - &  10000
    -    10000 -> 즉, S의 4번째 인덱스의 비트는 켜져있다!

## 🍎 비트마스킹을 이용한 경우의 수
- 비트마스킹은 경우의 수를 표현하는데도 잘 쓰인다.
- 예를 들어 {사과, 딸기, 포도, 배}의 모든 경우의 수는 어떻게 될까?
- { 사과 }
- { 사과, 딸기 }
- ...
- 총 16가지 2^4
